<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FlowMCP Configurator - Your Agent's Gateway to the World</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0a0a;
            min-height: 100vh;
            padding: 20px;
            color: #e2e8f0;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: transparent;
            border-radius: 20px;
            padding: 30px;
        }

        h1 {
            text-align: center;
            color: #ffffff;
            margin-bottom: 40px;
            font-size: 2.8rem;
            font-weight: 700;
        }

        .sticky-header {
            position: sticky;
            top: 0;
            z-index: 1000;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 25px;
            background: #1a1a1a;
            border-radius: 12px;
            color: white;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            margin-bottom: 30px;
            border: 1px solid #2d2d2d;
            /* Safari 16.4 specific fixes */
            -webkit-transform: translateZ(0);
            -webkit-backface-visibility: hidden;
            -webkit-perspective: 1000;
            transform: translateZ(0);
            backface-visibility: hidden;
            perspective: 1000px;
            /* Smooth transitions for Safari */
            -webkit-transition: background-color 0.25s ease-out,
                               border-radius 0.25s ease-out,
                               padding 0.25s ease-out,
                               box-shadow 0.25s ease-out;
            transition: background-color 0.25s ease-out,
                       border-radius 0.25s ease-out,
                       padding 0.25s ease-out,
                       box-shadow 0.25s ease-out;
        }

        .sticky-header.scrolled {
            background: #0a0a0a;
            border-radius: 0;
            margin-bottom: 0;
            padding: 12px 25px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        /* Safari specific optimizations */
        @supports (-webkit-backdrop-filter: blur(10px)) {
            .sticky-header {
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }
        }

        .sticky-header.scrolled .header-search {
            display: flex;
            opacity: 1;
            flex: 1;
            max-width: 400px;
            margin: 0 20px;
        }

        .header-search {
            display: none;
            opacity: 0;
            transition: all 0.3s ease;
        }

        .header-search .search-input {
            width: 100%;
            padding: 10px 15px;
            border: 1px solid #2d2d2d;
            border-radius: 25px;
            font-size: 14px;
            background: #1a1a1a;
            color: #e2e8f0;
            transition: all 0.3s ease;
        }

        .header-search .search-input:focus {
            outline: none;
            border-color: #ff5722;
            box-shadow: 0 0 0 2px rgba(255, 87, 34, 0.1);
        }

        .header-left {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .header-stat {
            text-align: center;
            background: rgba(255, 87, 34, 0.1);
            padding: 8px 16px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
            min-width: 90px;
            border: 1px solid rgba(255, 87, 34, 0.2);
        }

        .header-stat .stat-number {
            font-size: 1.5rem;
            font-weight: bold;
            display: block;
            margin-bottom: 1px;
        }

        .header-stat .stat-label {
            font-size: 0.8rem;
            opacity: 0.9;
            font-weight: 500;
            color: #ff5722;
        }

        .primary-btn {
            background: #ff5722;
            color: white;
            border: 2px solid #ff5722;
            padding: 10px 18px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 13px;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
        }

        .primary-btn:hover {
            background: #e64a19;
            border-color: #e64a19;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 87, 34, 0.3);
        }

        .text-btn {
            background: none;
            border: none;
            color: #e2e8f0;
            cursor: pointer;
            font-weight: 500;
            font-size: 14px;
            text-decoration: none;
            padding: 10px 12px;
            border-radius: 6px;
            transition: all 0.2s ease;
        }

        .text-btn:hover {
            color: #ff5722;
            background: rgba(255, 87, 34, 0.1);
        }

        .search-container {
            margin-bottom: 30px;
            position: relative;
        }

        .search-input {
            width: 100%;
            padding: 15px 20px;
            border: 2px solid #2d2d2d;
            border-radius: 50px;
            font-size: 16px;
            transition: all 0.3s ease;
            background: #1a1a1a;
            color: #e2e8f0;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }

        .search-input:focus {
            outline: none;
            border-color: #ff5722;
            box-shadow: 0 0 0 3px rgba(255, 87, 34, 0.1);
            transform: translateY(-2px);
        }

        .search-input::placeholder {
            color: #718096;
        }

        .namespace-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 25px;
            margin-bottom: 30px;
        }

        .namespace-card {
            background: #1a1a1a;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            border: 1px solid #2d2d2d;
            position: relative;
            overflow: hidden;
            cursor: pointer;
        }

        .namespace-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: #ff5722;
            transform: scaleX(0);
            transition: transform 0.3s ease;
        }

        .namespace-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.4);
            border-color: #ff5722;
        }

        .namespace-card:hover::before {
            transform: scaleX(1);
        }

        .namespace-card.selected {
            border-color: #ff5722;
            background: #262626;
        }

        .namespace-card.selected::before {
            transform: scaleX(1);
        }

        .namespace-description {
            color: #a0aec0;
            font-size: 0.9rem;
            line-height: 1.4;
            margin-bottom: 15px;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .credential-badge {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
            margin-bottom: 10px;
            text-transform: uppercase;
        }

        .credential-badge.required {
            background: #f44336;
            color: white;
        }

        .credential-badge.not-required {
            background: rgba(76, 175, 80, 0.1);
            color: #4caf50;
            border: 1px solid rgba(76, 175, 80, 0.3);
        }

        .routes-preview {
            margin-bottom: 15px;
        }

        .routes-preview-toggle {
            background: none;
            border: none;
            color: #ff5722;
            font-size: 0.85rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 5px;
            font-weight: 500;
            transition: color 0.2s ease;
        }

        .routes-preview-toggle:hover {
            color: #e64a19;
        }

        .routes-preview-toggle .arrow {
            transition: transform 0.2s ease;
        }

        .routes-preview-toggle.expanded .arrow {
            transform: rotate(90deg);
        }

        .namespace-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
        }

        .namespace-name {
            font-size: 1.3rem;
            font-weight: 600;
            color: #ffffff;
            margin: 0;
        }

        .namespace-toggle {
            position: relative;
            width: 90px;
            height: 35px;
            background: #2d2d2d;
            border-radius: 35px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .toggle-slider {
            position: absolute;
            width: 28px;
            height: 28px;
            background: white;
            border-radius: 50%;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            left: 4px;
            top: 50%;
            transform: translateY(-50%);
        }

        .toggle-text {
            font-size: 10px;
            font-weight: 600;
            color: #a0aec0;
            z-index: 1;
            transition: all 0.3s ease;
        }

        .namespace-toggle.disabled {
            background: #f44336;
        }

        .namespace-toggle.disabled .toggle-slider {
            left: 4px;
        }

        .namespace-toggle.disabled .toggle-text {
            color: white;
        }

        .namespace-toggle.manual {
            background: #9c27b0;
        }

        .namespace-toggle.manual .toggle-slider {
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .namespace-toggle.manual .toggle-text {
            color: white;
        }

        .namespace-toggle.enabled {
            background: #4caf50;
        }

        .namespace-toggle.enabled .toggle-slider {
            left: calc(100% - 32px);
        }

        .namespace-toggle.enabled .toggle-text {
            color: white;
        }

        .route-count {
            font-size: 0.9rem;
            color: #718096;
            margin-bottom: 15px;
        }

        .routes-container {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, padding 0.3s ease;
            border-radius: 10px;
            background: #0f0f0f;
            padding: 0;
        }

        .routes-container.expanded {
            max-height: 400px;
            overflow-y: auto;
            padding: 15px;
        }

        .route-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 12px;
            margin-bottom: 6px;
            background: #1a1a1a;
            border-radius: 6px;
            transition: all 0.2s ease;
            border-left: 3px solid transparent;
            border: 1px solid #2d2d2d;
        }

        .route-item:hover {
            background: #262626;
            border-left-color: #ff5722;
            border-color: #404040;
            transform: translateX(2px);
        }

        .route-item:last-child {
            margin-bottom: 0;
        }

        .route-name {
            font-weight: 500;
            color: #e2e8f0;
            flex: 1;
        }

        .route-toggle {
            position: relative;
            width: 44px;
            height: 24px;
        }

        .route-toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .route-toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #2d2d2d;
            transition: 0.3s;
            border-radius: 24px;
        }

        .route-toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        }

        .route-toggle input:checked + .route-toggle-slider {
            background: #4caf50;
        }

        .route-toggle input:checked + .route-toggle-slider:before {
            transform: translateX(20px);
        }

        .stats-container {
            background: #1a1a1a;
            color: white;
            padding: 25px;
            border-radius: 15px;
            margin-top: 30px;
            text-align: center;
            border: 1px solid #2d2d2d;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .stat-item {
            background: rgba(255, 87, 34, 0.1);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 87, 34, 0.2);
        }

        .stat-number {
            font-size: 2rem;
            font-weight: bold;
            display: block;
        }

        .stat-label {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .hidden {
            display: none;
        }

        .no-results {
            text-align: center;
            padding: 50px;
            color: #a0aec0;
            font-size: 1.1rem;
        }

            @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            .namespace-grid {
                grid-template-columns: 1fr;
            }
            
            h1 {
                font-size: 2rem;
            }

            .export-buttons {
                flex-direction: column;
                gap: 10px;
            }

            .selected-routes-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 15px;
            }

            .sticky-header {
                flex-direction: column;
                gap: 15px;
                text-align: center;
            }

            .header-left {
                flex-direction: column;
                gap: 15px;
            }

            .header-right {
                flex-direction: column;
                gap: 10px;
                width: 100%;
            }

            .header-stat {
                min-width: auto;
            }

            .share-btn {
                width: 100%;
                max-width: 200px;
            }

            .namespace-group-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }

            .namespace-group-right {
                width: 100%;
                justify-content: space-between;
            }

            .routes-list {
                grid-template-columns: 1fr;
            }
        }

        .selected-routes-container {
            background: #1a1a1a;
            border-radius: 15px;
            padding: 30px;
            margin-top: 30px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
            border: 1px solid #2d2d2d;
        }

        .selected-routes-container.collapsed .selected-routes-content {
            display: none;
        }

        .selected-routes-container.collapsed {
            padding-bottom: 20px;
        }

        .selected-routes-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 2px solid #2d2d2d;
            cursor: pointer;
            user-select: none;
        }

        .selected-routes-header .collapse-indicator {
            font-size: 14px;
            color: #a0aec0;
            transition: transform 0.2s ease;
            margin-right: 8px;
        }

        .selected-routes-container.collapsed .collapse-indicator {
            transform: rotate(-90deg);
        }

        .selected-routes-header h2 {
            color: #ffffff;
            margin: 0;
            font-size: 1.8rem;
        }

        .export-buttons {
            display: flex;
            gap: 15px;
        }

        .export-btn {
            background: #2d2d2d;
            color: #e2e8f0;
            border: 2px solid #404040;
            padding: 10px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 13px;
            transition: all 0.3s ease;
            min-width: 120px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .export-btn:hover {
            transform: translateY(-2px);
            background: #404040;
            border-color: #555555;
        }

        .export-btn:active {
            transform: translateY(0);
        }

        .selected-routes-content {
            min-height: 100px;
        }

        .no-selection {
            text-align: center;
            padding: 40px;
            color: #a0aec0;
        }

        .no-selection p {
            font-size: 1.2rem;
            margin-bottom: 10px;
        }

        .no-selection small {
            color: #718096;
            font-size: 0.9rem;
        }

        .namespace-group {
            margin-bottom: 20px;
            background: #0f0f0f;
            border-radius: 12px;
            padding: 20px;
            border-left: 4px solid transparent;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .namespace-group.collapsed {
            padding-bottom: 10px;
        }

        .namespace-group.collapsed .routes-list {
            display: none;
        }

        .namespace-group.collapsed .collapse-indicator {
            transform: rotate(-90deg);
        }

        .namespace-group.enabled {
            border-left-color: #4caf50;
            background: rgba(76, 175, 80, 0.1);
        }

        .namespace-group.manual {
            border-left-color: #9c27b0;
            background: rgba(156, 39, 176, 0.1);
        }

        .namespace-group-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #2d2d2d;
            user-select: none;
        }

        .namespace-group-left {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .collapse-indicator {
            font-size: 12px;
            color: #a0aec0;
            transition: transform 0.2s ease;
        }

        .namespace-group-right {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .route-count-badge {
            background: rgba(255, 87, 34, 0.1);
            color: #ff5722;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
        }

        .namespace-group-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: #ffffff;
            margin: 0;
        }

        .namespace-status-badge {
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .namespace-status-badge.enabled {
            background: #4caf50;
            color: white;
        }

        .namespace-status-badge.manual {
            background: #9c27b0;
            color: white;
        }

        .routes-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 10px;
        }

        .route-badge {
            background: #1a1a1a;
            padding: 12px 16px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            color: #e2e8f0;
            border: 1px solid #2d2d2d;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: all 0.2s ease;
        }

        .route-badge:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .route-method {
            font-weight: bold;
            margin-right: 8px;
        }

        .route-method.get { color: #4caf50; }
        .route-method.post { color: #2196f3; }
        .route-method.put { color: #ff5722; }
        .route-method.delete { color: #f44336; }

        .config-generator-container {
            background: #1a1a1a;
            border-radius: 15px;
            padding: 30px;
            margin-top: 30px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
            border: 1px solid #2d2d2d;
        }

        .config-generator-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 2px solid #2d2d2d;
        }

        .config-generator-header h2 {
            color: #ffffff;
            margin: 0;
            font-size: 1.8rem;
        }

        .config-buttons {
            display: flex;
            gap: 15px;
        }

        .config-btn {
            border: none;
            padding: 10px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 13px;
            transition: all 0.3s ease;
            background: #2d2d2d;
            color: #e2e8f0;
            border: 2px solid #404040;
            min-width: 120px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .config-btn.primary {
            background: #ff5722;
            color: white;
            border-color: transparent;
            box-shadow: 0 4px 12px rgba(255, 87, 34, 0.3);
        }

        .config-btn:hover {
            transform: translateY(-2px);
        }

        .config-btn.primary:hover {
            box-shadow: 0 6px 20px rgba(255, 87, 34, 0.4);
        }

        .config-btn:not(.primary):hover {
            background: #404040;
            border-color: #555555;
        }

        .config-btn:active {
            transform: translateY(0);
        }

        .config-content {
            position: relative;
        }

        .config-preview {
            background: #0f0f0f;
            border-radius: 12px;
            padding: 25px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.6;
            color: #e2e8f0;
            max-height: 500px;
            overflow-y: auto;
            border: 1px solid #2d2d2d;
            position: relative;
        }

        .config-placeholder {
            text-align: center;
            padding: 40px;
            color: #718096;
        }

        .config-placeholder p {
            font-size: 1.1rem;
            margin-bottom: 10px;
            font-family: 'Segoe UI', sans-serif;
        }

        .config-placeholder small {
            color: #a0aec0;
            font-size: 0.9rem;
            font-family: 'Segoe UI', sans-serif;
        }

        .json-content {
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .json-key {
            color: #ff5722;
        }

        .json-string {
            color: #4caf50;
        }

        .json-number {
            color: #ffc107;
        }

        .json-boolean {
            color: #2196f3;
        }

        .config-btn.share,
        .export-btn.share {
            background: #9c27b0;
            color: white;
            border-color: transparent;
            box-shadow: 0 4px 12px rgba(156, 39, 176, 0.3);
        }

        .config-btn.share:hover,
        .export-btn.share:hover {
            box-shadow: 0 6px 20px rgba(156, 39, 176, 0.4);
        }

        .url-notification {
            position: sticky;
            top: 10px;
            left: 50%;
            transform: translateX(-50%) translateY(-100px);
            background: #4caf50;
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            box-shadow: 0 8px 25px rgba(76, 175, 80, 0.3);
            z-index: 9999;
            transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            max-width: 90vw;
            text-align: center;
            margin: 0 auto;
            width: fit-content;
        }

        .url-notification.show {
            transform: translateX(-50%) translateY(0);
        }

        .url-notification .close-btn {
            background: none;
            border: none;
            color: white;
            font-size: 18px;
            cursor: pointer;
            position: absolute;
            top: 10px;
            right: 15px;
            padding: 0;
            line-height: 1;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s ease;
        }

        .url-notification .close-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .config-restored-banner {
            background: #2196f3;
            color: white;
            padding: 15px;
            text-align: center;
            margin-bottom: 20px;
            border-radius: 10px;
            display: none;
            animation: slideInDown 0.5s ease;
        }

        @keyframes slideInDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .config-restored-banner .dismiss-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            padding: 5px 15px;
            border-radius: 15px;
            cursor: pointer;
            margin-left: 15px;
            font-size: 12px;
            transition: background 0.2s ease;
        }

        .config-restored-banner .dismiss-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="configRestoredBanner" class="config-restored-banner">
            <span>‚ú® Configuration loaded from shared link!</span>
            <button class="dismiss-btn" onclick="dismissRestoredBanner()">Got it</button>
        </div>
        
        <header style="text-align: center; margin-bottom: 40px;">
            <div style="display: flex; align-items: center; justify-content: center; gap: 15px; margin-bottom: 20px;">
                <div style="width: 50px; height: 50px; background: #ff5722; border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 24px; font-weight: bold; color: white;">F</div>
                <h1 style="margin: 0;">FlowMCP Configurator</h1>
            </div>
            <p style="font-size: 1.2rem; color: #a0aec0; margin: 0; font-weight: 300;">Simple configuration for FlowMCP Server - Select namespaces and routes.</p>
        </header>
        
        <div class="sticky-header" id="stickyHeader">
            <div class="header-left">
                <div class="header-stat">
                    <span id="topActiveNamespaces" class="stat-number">0</span>
                    <span class="stat-label">Active Namespaces</span>
                </div>
                <div class="header-stat">
                    <span id="topActiveRoutes" class="stat-number">0</span>
                    <span class="stat-label">Active Routes</span>
                </div>
            </div>
            <div class="header-search">
                <input type="text" id="headerSearchInput" class="search-input" placeholder="Search namespaces...">
            </div>
            <div class="header-right">
                <button id="resetAllBtn" class="text-btn">Reset All</button>
                <button id="shareConfigBtn" class="text-btn">Share Config</button>
                <button id="getConfigBtn" class="primary-btn">Get Config</button>
            </div>
        </div>
        
        <div class="search-container">
            <input type="text" id="searchInput" class="search-input" placeholder="send messages and reach thousands of namespaces...">
        </div>

        <div id="namespaceContainer" class="namespace-grid"></div>
        
        <div id="noResults" class="no-results hidden">
            <p>No namespaces found ü§∑‚Äç‚ôÇÔ∏è</p>
        </div>


        <div class="selected-routes-container" id="selectedRoutesContainer">
            <div class="selected-routes-header" onclick="toggleSelectedRoutesOverview()">
                <h2><span class="collapse-indicator">‚ñº</span>Selected Routes Overview</h2>
                <div class="export-buttons">
                    <button id="copyListBtn" class="export-btn" onclick="event.stopPropagation()">üìã Copy List</button>
                </div>
            </div>
            <div id="selectedRoutesContent" class="selected-routes-content">
                <div class="no-selection">
                    <p>ü§∑‚Äç‚ôÇÔ∏è No routes selected</p>
                    <small>Enable namespaces or individual routes to see them here.</small>
                </div>
            </div>
        </div>

        <div class="config-generator-container">
            <div class="config-generator-header">
                <h2>MCP Server Configuration</h2>
                <div class="config-buttons">
                    <button id="copyConfigBtn" class="config-btn">Copy Config</button>
                </div>
            </div>
            <div class="config-content">
                <div class="config-preview" id="configPreview">
                    <div class="config-placeholder">
                        <p>üîß Click "Generate Configuration" to create the MCP Server Config</p>
                        <small>The configuration will be automatically generated based on your selected namespaces.</small>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Data will be loaded from routes.json
        let namespacesData = [];

        // State for each namespace and its routes
        let namespaceStates = {};
        
        // Track current display order to maintain stability
        let currentDisplayOrder = [];
        let hasInitialSortBeenApplied = false;

        // Namespace state types
        const NAMESPACE_STATES = {
            DISABLED: 'disabled',
            MANUAL: 'manual', 
            ENABLED: 'enabled'
        };

        // Load routes data from JSON file
        async function loadRoutesData() {
            try {
                const response = await fetch('./routes.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                namespacesData = await response.json();
                initializeStates();
                return true;
            } catch (error) {
                console.error('Error loading routes data:', error);
                // Fallback: show error message to user
                document.getElementById('namespaceContainer').innerHTML = `
                    <div style="text-align: center; padding: 50px; color: #e53e3e;">
                        <h3>Error Loading Data</h3>
                        <p>Could not load routes configuration. Please try again later.</p>
                        <p style="font-size: 0.9rem; color: #718096;">Error: ${error.message}</p>
                    </div>
                `;
                return false;
            }
        }

        // Initialize states
        function initializeStates() {
            namespacesData.forEach(namespace => {
                namespaceStates[namespace.name] = {
                    state: NAMESPACE_STATES.DISABLED,
                    routes: {}
                };
                namespace.routes.forEach(route => {
                    namespaceStates[namespace.name].routes[route] = false;
                });
            });
        }

        // Determine namespace state based on route states
        function determineNamespaceState(namespaceName) {
            const routes = namespaceStates[namespaceName].routes;
            const routeValues = Object.values(routes);
            const enabledCount = routeValues.filter(enabled => enabled).length;
            
            if (enabledCount === 0) {
                return NAMESPACE_STATES.DISABLED;
            } else if (enabledCount === routeValues.length) {
                return NAMESPACE_STATES.ENABLED;
            } else {
                return NAMESPACE_STATES.MANUAL;
            }
        }

        // Namespace toggle handler (cycle through 3 states)
        function toggleNamespace(namespaceName) {
            const currentState = namespaceStates[namespaceName].state;
            let newState;
            
            // Check if routes are currently expanded to preserve state
            const routesContainer = document.getElementById(`routes-${namespaceName}`);
            const wasExpanded = routesContainer && routesContainer.classList.contains('expanded');
            let scrollPosition = 0;
            
            // Save scroll position if container was expanded
            if (wasExpanded) {
                scrollPosition = routesContainer.scrollTop;
            }
            
            switch (currentState) {
                case NAMESPACE_STATES.DISABLED:
                    newState = NAMESPACE_STATES.ENABLED;
                    // Activate all routes
                    Object.keys(namespaceStates[namespaceName].routes).forEach(route => {
                        namespaceStates[namespaceName].routes[route] = true;
                    });
                    break;
                case NAMESPACE_STATES.ENABLED:
                    newState = NAMESPACE_STATES.DISABLED;
                    // Deactivate all routes
                    Object.keys(namespaceStates[namespaceName].routes).forEach(route => {
                        namespaceStates[namespaceName].routes[route] = false;
                    });
                    break;
                case NAMESPACE_STATES.MANUAL:
                    newState = NAMESPACE_STATES.DISABLED;
                    // Deactivate all routes
                    Object.keys(namespaceStates[namespaceName].routes).forEach(route => {
                        namespaceStates[namespaceName].routes[route] = false;
                    });
                    break;
            }
            
            namespaceStates[namespaceName].state = newState;
            updateDisplay();
            updateStats();
            
            // Restore expanded state and scroll position if it was expanded before
            if (wasExpanded) {
                const newRoutesContainer = document.getElementById(`routes-${namespaceName}`);
                if (newRoutesContainer) {
                    newRoutesContainer.classList.add('expanded');
                    // Restore scroll position
                    newRoutesContainer.scrollTop = scrollPosition;
                    
                    // Also update the button state
                    const toggleButton = newRoutesContainer.parentElement.querySelector('.routes-preview-toggle');
                    if (toggleButton) {
                        toggleButton.classList.add('expanded');
                        const arrow = toggleButton.querySelector('.arrow');
                        const text = toggleButton.querySelector('span:last-child');
                        if (arrow) arrow.style.transform = 'rotate(90deg)';
                        if (text) text.textContent = 'Hide routes';
                    }
                }
            }
        }

        // Route toggle handler
        function toggleRoute(namespaceName, routeName) {
            namespaceStates[namespaceName].routes[routeName] = !namespaceStates[namespaceName].routes[routeName];
            
            // Automatically determine namespace state
            namespaceStates[namespaceName].state = determineNamespaceState(namespaceName);
            
            // Keep the routes preview expanded when toggling individual routes
            const routesContainer = document.getElementById(`routes-${namespaceName}`);
            const wasExpanded = routesContainer && routesContainer.classList.contains('expanded');
            let scrollPosition = 0;
            
            // Save scroll position if container was expanded
            if (wasExpanded) {
                scrollPosition = routesContainer.scrollTop;
            }
            
            updateDisplay();
            updateStats();
            
            // Restore expanded state and scroll position if it was expanded before
            if (wasExpanded) {
                const newRoutesContainer = document.getElementById(`routes-${namespaceName}`);
                if (newRoutesContainer) {
                    newRoutesContainer.classList.add('expanded');
                    // Restore scroll position
                    newRoutesContainer.scrollTop = scrollPosition;
                    
                    // Also update the button state
                    const toggleButton = newRoutesContainer.parentElement.querySelector('.routes-preview-toggle');
                    if (toggleButton) {
                        toggleButton.classList.add('expanded');
                        const arrow = toggleButton.querySelector('.arrow');
                        const text = toggleButton.querySelector('span:last-child');
                        if (arrow) arrow.style.transform = 'rotate(90deg)';
                        if (text) text.textContent = 'Hide routes';
                    }
                }
            }
        }

        // Create namespace card
        function createNamespaceCard(namespace) {
            const state = namespaceStates[namespace.name].state;
            const activeRoutes = Object.values(namespaceStates[namespace.name].routes).filter(enabled => enabled).length;
            
            let stateText = '';
            let stateClass = '';
            
            switch (state) {
                case NAMESPACE_STATES.DISABLED:
                    stateText = 'OFF';
                    stateClass = 'disabled';
                    break;
                case NAMESPACE_STATES.MANUAL:
                    stateText = 'SELECTION';
                    stateClass = 'manual';
                    break;
                case NAMESPACE_STATES.ENABLED:
                    stateText = 'ON';
                    stateClass = 'enabled';
                    break;
            }

            const credentialBadge = namespace.requiresCredential 
                ? `<div class="credential-badge required">üîê Credential Required</div>`
                : `<div class="credential-badge not-required">üîì No Credential</div>`;
            
            return `
                <div class="namespace-card ${state !== NAMESPACE_STATES.DISABLED ? 'selected' : ''}" data-namespace="${namespace.name}">
                    <div class="namespace-header">
                        <h3 class="namespace-name">${namespace.name}</h3>
                        <div class="namespace-toggle ${stateClass}" onclick="toggleNamespace('${namespace.name}')">
                            <div class="toggle-slider"></div>
                            <span class="toggle-text">${stateText}</span>
                        </div>
                    </div>
                    <div class="namespace-description">${namespace.description}</div>
                    ${credentialBadge}
                    <div class="route-count">
                        ${activeRoutes}/${namespace.routes.length} routes activated
                    </div>
                    <div class="routes-preview">
                        <button class="routes-preview-toggle" onclick="toggleRoutesPreview(event, '${namespace.name}')">
                            <span class="arrow">‚ñ∂</span>
                            <span>Show routes</span>
                        </button>
                    </div>
                    <div class="routes-container" id="routes-${namespace.name}">
                        ${namespace.routes.map(route => `
                            <div class="route-item">
                                <span class="route-name">${route}</span>
                                <label class="route-toggle">
                                    <input type="checkbox" ${namespaceStates[namespace.name].routes[route] ? 'checked' : ''} 
                                           onchange="toggleRoute('${namespace.name}', '${route}')">
                                    <span class="route-toggle-slider"></span>
                                </label>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        }

        // Toggle f√ºr Routen-Preview
        function toggleRoutesPreview(event, namespaceName) {
            event.stopPropagation();
            const container = document.getElementById(`routes-${namespaceName}`);
            const button = event.currentTarget;
            const arrow = button.querySelector('.arrow');
            const text = button.querySelector('span:last-child');
            
            if (container.classList.contains('expanded')) {
                container.classList.remove('expanded');
                button.classList.remove('expanded');
                arrow.style.transform = 'rotate(0deg)';
                text.textContent = 'Show routes';
            } else {
                container.classList.add('expanded');
                button.classList.add('expanded');
                arrow.style.transform = 'rotate(90deg)';
                text.textContent = 'Hide routes';
            }
        }

        // Update display
        function updateDisplay() {
            const container = document.getElementById('namespaceContainer');
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            
            let filteredNamespaces = namespacesData.filter(namespace => 
                namespace.name.toLowerCase().includes(searchTerm)
            );
            
            // EXPERIMENT: Apply smart sorting
            if (!hasInitialSortBeenApplied) {
                // First time: Sort active namespaces first
                filteredNamespaces.sort((a, b) => {
                    const aState = namespaceStates[a.name].state;
                    const bState = namespaceStates[b.name].state;
                    
                    const aIsActive = aState === NAMESPACE_STATES.ENABLED || aState === NAMESPACE_STATES.MANUAL;
                    const bIsActive = bState === NAMESPACE_STATES.ENABLED || bState === NAMESPACE_STATES.MANUAL;
                    
                    // If one is active and the other isn't, active comes first
                    if (aIsActive && !bIsActive) return -1;
                    if (!aIsActive && bIsActive) return 1;
                    
                    // If both have same active status, sort alphabetically
                    return a.name.localeCompare(b.name);
                });
                
                // Save this order as the reference
                currentDisplayOrder = filteredNamespaces.map(ns => ns.name);
                hasInitialSortBeenApplied = true;
            } else {
                // Subsequent times: Maintain existing order but move individual items as needed
                filteredNamespaces.sort((a, b) => {
                    const aState = namespaceStates[a.name].state;
                    const bState = namespaceStates[b.name].state;
                    
                    const aIsActive = aState === NAMESPACE_STATES.ENABLED || aState === NAMESPACE_STATES.MANUAL;
                    const bIsActive = bState === NAMESPACE_STATES.ENABLED || bState === NAMESPACE_STATES.MANUAL;
                    
                    const aIndex = currentDisplayOrder.indexOf(a.name);
                    const bIndex = currentDisplayOrder.indexOf(b.name);
                    
                    // If both are in current order, maintain that order
                    if (aIndex !== -1 && bIndex !== -1) {
                        return aIndex - bIndex;
                    }
                    
                    // If one is active and other isn't, active comes first
                    if (aIsActive && !bIsActive) return -1;
                    if (!aIsActive && bIsActive) return 1;
                    
                    // Otherwise alphabetical
                    return a.name.localeCompare(b.name);
                });
            }
            
            if (filteredNamespaces.length === 0) {
                container.innerHTML = '';
                document.getElementById('noResults').classList.remove('hidden');
            } else {
                document.getElementById('noResults').classList.add('hidden');
                container.innerHTML = filteredNamespaces.map(createNamespaceCard).join('');
            }
        }

        // Update statistics
        function updateStats() {
            const totalNamespaces = namespacesData.length;
            const enabledNamespaces = Object.values(namespaceStates).filter(ns => ns.state === NAMESPACE_STATES.ENABLED).length;
            const manualNamespaces = Object.values(namespaceStates).filter(ns => ns.state === NAMESPACE_STATES.MANUAL).length;
            const activeNamespaces = enabledNamespaces + manualNamespaces;
            
            let totalRoutes = 0;
            let activeRoutes = 0;
            
            namespacesData.forEach(namespace => {
                totalRoutes += namespace.routes.length;
                activeRoutes += Object.values(namespaceStates[namespace.name].routes).filter(enabled => enabled).length;
            });
            
            // Update header statistics
            document.getElementById('topActiveNamespaces').textContent = activeNamespaces;
            document.getElementById('topActiveRoutes').textContent = activeRoutes;
            
            // Update selected routes
            updateSelectedRoutes();
            
            // Automatically generate MCP configuration
            autoGenerateMcpConfig();
            
            // Automatically update URL
            autoUpdateUrl();
        }

        // Display selected routes
        function updateSelectedRoutes() {
            const container = document.getElementById('selectedRoutesContent');
            
            // Safety check
            if (!container) {
                console.error('Selected routes container not found');
                return;
            }
            
            const selectedRoutes = getSelectedRoutes();
            
            if (selectedRoutes.length === 0) {
                container.innerHTML = `
                    <div class="no-selection">
                        <p>ü§∑‚Äç‚ôÇÔ∏è No routes selected</p>
                        <small>Activate namespaces or individual routes to see them here.</small>
                    </div>
                `;
                return;
            }

            // Group routes by namespace
            const groupedRoutes = {};
            selectedRoutes.forEach(item => {
                if (!groupedRoutes[item.namespace]) {
                    groupedRoutes[item.namespace] = {
                        routes: [],
                        state: namespaceStates[item.namespace].state
                    };
                }
                groupedRoutes[item.namespace].routes.push(item.route);
            });

            let html = '';
            Object.entries(groupedRoutes).forEach(([namespace, data]) => {
                const stateClass = data.state === NAMESPACE_STATES.ENABLED ? 'enabled' : 'manual';
                const stateText = data.state === NAMESPACE_STATES.ENABLED ? 'Complete' : 'Selection';
                const routeCount = data.routes.length;
                
                html += `
                    <div class="namespace-group ${stateClass} collapsed" onclick="toggleNamespaceGroup('${namespace}')">
                        <div class="namespace-group-header">
                            <div class="namespace-group-left">
                                <span class="collapse-indicator">‚ñ∂</span>
                                <h3 class="namespace-group-title">${namespace}</h3>
                            </div>
                            <div class="namespace-group-right">
                                <span class="route-count-badge">${routeCount} Route${routeCount > 1 ? 's' : ''}</span>
                                <span class="namespace-status-badge ${stateClass}">${stateText}</span>
                            </div>
                        </div>
                        <div class="routes-list">
                            ${data.routes.map(route => {
                                const method = route.split(' ')[0];
                                const path = route.split(' ')[1] || route;
                                return `
                                    <div class="route-badge">
                                        <span class="route-method ${method.toLowerCase()}">${method}</span>
                                        <span class="route-path">${path}</span>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        // Alle ausgew√§hlten Routen sammeln
        function getSelectedRoutes() {
            const selectedRoutes = [];
            
            namespacesData.forEach(namespace => {
                Object.entries(namespaceStates[namespace.name].routes).forEach(([route, enabled]) => {
                    if (enabled) {
                        selectedRoutes.push({
                            namespace: namespace.name,
                            route: route
                        });
                    }
                });
            });
            
            return selectedRoutes;
        }

        // JSON Export
        function exportToJson() {
            const selectedRoutes = getSelectedRoutes();
            const exportData = {
                timestamp: new Date().toISOString(),
                totalSelected: selectedRoutes.length,
                namespaces: {}
            };

            selectedRoutes.forEach(item => {
                if (!exportData.namespaces[item.namespace]) {
                    exportData.namespaces[item.namespace] = {
                        state: namespaceStates[item.namespace].state,
                        routes: []
                    };
                }
                exportData.namespaces[item.namespace].routes.push(item.route);
            });

            const jsonString = JSON.stringify(exportData, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `selected-routes-${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Liste kopieren
        function copyToClipboard() {
            const selectedRoutes = getSelectedRoutes();
            
            if (selectedRoutes.length === 0) {
                alert('No routes selected for copying!');
                return;
            }

            let text = `Selected Routes (${selectedRoutes.length}):\n\n`;
            
            const groupedRoutes = {};
            selectedRoutes.forEach(item => {
                if (!groupedRoutes[item.namespace]) {
                    groupedRoutes[item.namespace] = [];
                }
                groupedRoutes[item.namespace].push(item.route);
            });

            Object.entries(groupedRoutes).forEach(([namespace, routes]) => {
                text += `${namespace}:\n`;
                routes.forEach(route => {
                    text += `  - ${route}\n`;
                });
                text += '\n';
            });

            navigator.clipboard.writeText(text).then(() => {
                // Feedback f√ºr erfolgreiche Kopie
                const btn = document.getElementById('copyListBtn');
                const originalText = btn.textContent;
                btn.textContent = '‚úÖ Copied!';
                btn.style.background = '#48bb78';
                
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.background = '';
                }, 2000);
            }).catch(() => {
                alert('Error copying to clipboard');
            });
        }

        // ============= URL SHARING FUNKTIONEN =============

        // Aktuellen Zustand in URL kodieren
        function encodeStateToUrl() {
            const state = {
                namespaces: {},
                version: 1 // F√ºr zuk√ºnftige Kompatibilit√§t
            };

            // Namespace-Zust√§nde sammeln
            namespacesData.forEach(namespace => {
                const nsState = namespaceStates[namespace.name];
                if (nsState.state !== NAMESPACE_STATES.DISABLED) {
                    state.namespaces[namespace.name] = {
                        state: nsState.state,
                        routes: nsState.routes
                    };
                }
            });

            // JSON zu Base64 kodieren
            const jsonString = JSON.stringify(state);
            const base64String = btoa(unescape(encodeURIComponent(jsonString)));
            
            return base64String;
        }

        // Zustand aus URL dekodieren
        function decodeStateFromUrl(encodedState) {
            try {
                const jsonString = decodeURIComponent(escape(atob(encodedState)));
                const state = JSON.parse(jsonString);
                
                // Validierung
                if (!state.namespaces || typeof state.namespaces !== 'object') {
                    throw new Error('Invalid state format');
                }

                return state;
            } catch (error) {
                console.error('Error decoding state from URL:', error);
                return null;
            }
        }

        // Zustand aus URL laden
        function loadStateFromUrl() {
            const hash = window.location.hash;
            
            if (hash.startsWith('#config=')) {
                const encodedState = hash.substring(8); // Remove '#config='
                const state = decodeStateFromUrl(encodedState);
                
                if (state) {
                    applyStateFromUrl(state);
                    return true;
                }
            }
            return false;
        }

        // Zustand auf Interface anwenden
        function applyStateFromUrl(state) {
            // Erst alle Zust√§nde zur√ºcksetzen
            initializeStates();
            
            // Dann die geladenen Zust√§nde anwenden
            Object.entries(state.namespaces).forEach(([namespaceName, nsState]) => {
                if (namespaceStates[namespaceName]) {
                    namespaceStates[namespaceName].state = nsState.state;
                    Object.assign(namespaceStates[namespaceName].routes, nsState.routes);
                }
            });

            // Interface aktualisieren
            updateDisplay();
            updateStats();
            
            // Banner anzeigen
            showRestoredBanner();
        }

        // URL in Zwischenablage kopieren und aktualisieren
        function updateUrlAndShare(showNotification = true) {
            const encodedState = encodeStateToUrl();
            const currentUrl = window.location.href.split('#')[0];
            const shareUrl = `${currentUrl}#config=${encodedState}`;
            
            // URL aktualisieren ohne Reload
            window.history.replaceState(null, null, shareUrl);
            
            if (showNotification) {
                return shareUrl;
            }
        }

        // Share configuration (for routes section)
        function shareConfiguration() {
            const activeNamespaces = getActiveNamespaces();
            
            if (activeNamespaces.length === 0) {
                showUrlNotification('‚ö†Ô∏è No namespaces selected!', 'Please select at least one namespace to generate a link.');
                return;
            }

            const shareUrl = updateUrlAndShare();
            
            navigator.clipboard.writeText(shareUrl).then(() => {
                showUrlNotification('üîó Link copied!', 'The shareable link has been copied to your clipboard.');
            }).catch(() => {
                showUrlNotification('üîó Link generated!', shareUrl);
            });
        }

        // Share URL (for config section)
        function shareUrlConfiguration() {
            const activeNamespaces = getActiveNamespaces();
            
            if (activeNamespaces.length === 0) {
                showUrlNotification('‚ö†Ô∏è No namespaces selected!', 'Please select at least one namespace to generate a link.');
                return;
            }

            const shareUrl = updateUrlAndShare();
            
            navigator.clipboard.writeText(shareUrl).then(() => {
                showUrlNotification('üîó URL copied!', 'The shareable URL has been copied to your clipboard.');
            }).catch(() => {
                showUrlNotification('üîó URL generated!', shareUrl);
            });
        }

        // URL-Benachrichtigung anzeigen
        function showUrlNotification(title, message) {
            ensureDOMReady(() => {
                const notification = document.getElementById('urlNotification');
                const content = document.getElementById('notificationContent');
                
                // Safety check ob Elemente existieren
                if (!notification || !content) {
                    console.warn('Notification elements not found, retrying...');
                    // Retry nach kurzer Verz√∂gerung
                    setTimeout(() => showUrlNotification(title, message), 100);
                    return;
                }
                
                content.innerHTML = `
                    <div style="font-weight: 600; margin-bottom: 5px; padding-right: 30px;">${title}</div>
                    <div style="font-size: 13px; opacity: 0.9; padding-right: 30px;">${message}</div>
                `;
                
                notification.classList.add('show');
                
                // Auto-Hide nach 4 Sekunden
                setTimeout(() => {
                    hideUrlNotification();
                }, 4000);
            });
        }

        // URL-Benachrichtigung verstecken
        function hideUrlNotification() {
            ensureDOMReady(() => {
                const notification = document.getElementById('urlNotification');
                if (notification) {
                    notification.classList.remove('show');
                }
            });
        }

        // Banner f√ºr geladene Konfiguration anzeigen
        function showRestoredBanner() {
            ensureDOMReady(() => {
                const banner = document.getElementById('configRestoredBanner');
                if (banner) {
                    banner.style.display = 'block';
                }
            });
        }

        // Banner f√ºr geladene Konfiguration verstecken
        function dismissRestoredBanner() {
            const banner = document.getElementById('configRestoredBanner');
            if (banner) {
                banner.style.display = 'none';
            }
        }

        // URL automatisch bei √Ñnderungen aktualisieren
        function autoUpdateUrl() {
            const activeNamespaces = getActiveNamespaces();
            if (activeNamespaces.length > 0) {
                updateUrlAndShare(false);
            }
        }

        // Reset all selections
        function resetAllSelections() {
            // Reset all namespace states to disabled
            namespacesData.forEach(namespace => {
                namespaceStates[namespace.name].state = NAMESPACE_STATES.DISABLED;
                Object.keys(namespaceStates[namespace.name].routes).forEach(route => {
                    namespaceStates[namespace.name].routes[route] = false;
                });
            });
            
            // Reset display order for future sorting
            currentDisplayOrder = [];
            hasInitialSortBeenApplied = false;
            
            // Update display and stats
            updateDisplay();
            updateStats();
            
            // Clear URL hash
            window.history.replaceState(null, null, window.location.pathname);
        }

        // Event Listeners for Export-Buttons
        function setupExportButtons() {
            document.getElementById('copyListBtn').addEventListener('click', copyToClipboard);
            document.getElementById('copyConfigBtn').addEventListener('click', copyMcpConfig);
            document.getElementById('shareConfigBtn').addEventListener('click', shareConfiguration);
            document.getElementById('getConfigBtn').addEventListener('click', scrollToConfig);
            document.getElementById('resetAllBtn').addEventListener('click', resetAllSelections);
        }

        // Smooth scroll to configuration section
        function scrollToConfig() {
            const configSection = document.querySelector('.config-generator-container');
            if (configSection) {
                configSection.scrollIntoView({ 
                    behavior: 'smooth', 
                    block: 'start' 
                });
            }
        }

        // Toggle namespace group collapse/expand
        function toggleNamespaceGroup(namespace) {
            const group = event.currentTarget;
            group.classList.toggle('collapsed');
        }

        // Toggle Selected Routes Overview collapse/expand
        function toggleSelectedRoutesOverview() {
            const container = document.getElementById('selectedRoutesContainer');
            container.classList.toggle('collapsed');
        }


        // Aktive Namespaces sammeln
        function getActiveNamespaces() {
            return namespacesData
                .filter(namespace => {
                    const state = namespaceStates[namespace.name].state;
                    return state === NAMESPACE_STATES.ENABLED || state === NAMESPACE_STATES.MANUAL;
                })
                .map(namespace => namespace.name);
        }

        // Ben√∂tigte Credentials sammeln (nur die tats√§chlich erforderlichen)
        function getRequiredCredentials() {
            const credentials = {};

            // Nur Namespace-spezifische Credentials hinzuf√ºgen, die tats√§chlich aktiv sind
            namespacesData.forEach(namespace => {
                const state = namespaceStates[namespace.name].state;
                if ((state === NAMESPACE_STATES.ENABLED || state === NAMESPACE_STATES.MANUAL) && 
                    namespace.requiresCredential && 
                    namespace.credentialKey) {
                    credentials[namespace.credentialKey] = "";
                }
            });

            return credentials;
        }

        // Automatische MCP Konfiguration (wird bei jeder √Ñnderung aufgerufen)
        function autoGenerateMcpConfig() {
            const activeNamespaces = getActiveNamespaces();
            const requiredCredentials = getRequiredCredentials();
            
            const config = {
                "globalShortcut": "",
                "mcpServers": {
                    "FlowMCP": {
                        "command": "node",
                        "args": [
                            "./path/to/your/file.mjs",
                            "--launched-by=claude",
                            `--includeNamespaces=${activeNamespaces.join(',')}`,
                            "--excludeNamespaces=",
                            "--activateTags="
                        ],
                        "env": requiredCredentials
                    }
                }
            };

            displayConfig(config);
        }

        // Konfiguration anzeigen
        function displayConfig(config) {
            const preview = document.getElementById('configPreview');
            
            // Safety check
            if (!preview) {
                console.error('Config preview element not found');
                return;
            }
            
            // Pr√ºfen ob es aktive Namespaces gibt
            if (config.mcpServers.FlowMCP.args[2] === '--includeNamespaces=') {
                preview.innerHTML = `
                    <div class="config-placeholder">
                        <p>üîß No namespaces selected</p>
                        <small>Select namespaces to generate the MCP server configuration.</small>
                    </div>
                `;
                return;
            }
            
            const jsonString = JSON.stringify(config, null, 4);
            const highlightedJson = highlightJson(jsonString);
            
            preview.innerHTML = `<div class="json-content">${highlightedJson}</div>`;
        }

        // JSON Syntax Highlighting
        function highlightJson(json) {
            return json
                .replace(/(".*?")(\s*:)/g, '<span class="json-key">$1</span>$2')
                .replace(/:\s*(".*?")/g, ': <span class="json-string">$1</span>')
                .replace(/:\s*(\d+)/g, ': <span class="json-number">$1</span>')
                .replace(/:\s*(true|false)/g, ': <span class="json-boolean">$1</span>')
                .replace(/:\s*(null)/g, ': <span class="json-null">$1</span>');
        }

        // Konfiguration downloaden
        function downloadMcpConfig() {
            const activeNamespaces = getActiveNamespaces();
            
            if (activeNamespaces.length === 0) {
                alert('No namespaces selected! Please select at least one namespace.');
                return;
            }

            const requiredCredentials = getRequiredCredentials();
            
            const config = {
                "globalShortcut": "",
                "mcpServers": {
                    "FlowMCP": {
                        "command": "node",
                        "args": [
                            "./path/to/your/file.mjs",
                            "--launched-by=claude",
                            `--includeNamespaces=${activeNamespaces.join(',')}`,
                            "--excludeNamespaces=",
                            "--activateTags="
                        ],
                        "env": requiredCredentials
                    }
                }
            };

            const jsonString = JSON.stringify(config, null, 4);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `mcp-server-config-${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Konfiguration kopieren
        function copyMcpConfig() {
            const activeNamespaces = getActiveNamespaces();
            
            if (activeNamespaces.length === 0) {
                alert('No namespaces selected! Please select at least one namespace.');
                return;
            }

            const requiredCredentials = getRequiredCredentials();
            
            const config = {
                "globalShortcut": "",
                "mcpServers": {
                    "FlowMCP": {
                        "command": "node",
                        "args": [
                            "./path/to/your/file.mjs",
                            "--launched-by=claude",
                            `--includeNamespaces=${activeNamespaces.join(',')}`,
                            "--excludeNamespaces=",
                            "--activateTags="
                        ],
                        "env": requiredCredentials
                    }
                }
            };

            const jsonString = JSON.stringify(config, null, 4);
            
            navigator.clipboard.writeText(jsonString).then(() => {
                const btn = document.getElementById('copyConfigBtn');
                const originalText = btn.textContent;
                btn.textContent = '‚úÖ Copied!';
                btn.style.background = '#48bb78';
                btn.style.color = 'white';
                
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.background = '';
                    btn.style.color = '';
                }, 2000);
            }).catch(() => {
                alert('Error copying to clipboard');
            });
        }

        // Search function
        function setupSearch() {
            const searchInput = document.getElementById('searchInput');
            const headerSearchInput = document.getElementById('headerSearchInput');
            
            // Main search input
            searchInput.addEventListener('input', () => {
                // Sync with header search
                headerSearchInput.value = searchInput.value;
                updateDisplay();
            });
            
            // Header search input
            headerSearchInput.addEventListener('input', () => {
                // Sync with main search
                searchInput.value = headerSearchInput.value;
                updateDisplay();
            });
        }

        // Sticky header scroll functionality
        function setupStickyHeader() {
            const stickyHeader = document.getElementById('stickyHeader');
            const searchContainer = document.querySelector('.search-container');
            let isScrolled = false;
            let rafId = null;
            
            // Detect Safari
            const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
            
            function updateHeader() {
                const searchRect = searchContainer.getBoundingClientRect();
                const shouldBeScrolled = searchRect.bottom <= 0;
                
                if (shouldBeScrolled !== isScrolled) {
                    // For Safari, add a small delay to prevent jerk
                    if (isSafari) {
                        setTimeout(() => {
                            if (shouldBeScrolled) {
                                stickyHeader.classList.add('scrolled');
                            } else {
                                stickyHeader.classList.remove('scrolled');
                            }
                        }, 16); // One frame delay
                    } else {
                        if (shouldBeScrolled) {
                            stickyHeader.classList.add('scrolled');
                        } else {
                            stickyHeader.classList.remove('scrolled');
                        }
                    }
                    isScrolled = shouldBeScrolled;
                }
                
                rafId = null;
            }
            
            function handleScroll() {
                if (rafId === null) {
                    rafId = requestAnimationFrame(updateHeader);
                }
            }
            
            // For Safari 16.4, use scroll listener instead of Intersection Observer
            if (isSafari) {
                window.addEventListener('scroll', handleScroll, { passive: true });
            } else {
                // Use intersection observer for other browsers
                const observer = new IntersectionObserver(
                    ([entry]) => {
                        const shouldBeScrolled = !entry.isIntersecting;
                        if (shouldBeScrolled !== isScrolled) {
                            if (shouldBeScrolled) {
                                stickyHeader.classList.add('scrolled');
                            } else {
                                stickyHeader.classList.remove('scrolled');
                            }
                            isScrolled = shouldBeScrolled;
                        }
                    },
                    {
                        threshold: 0,
                        rootMargin: '0px 0px -1px 0px'
                    }
                );
                
                observer.observe(searchContainer);
            }
            
            updateHeader(); // Initial check
        }

        // Initialization
        async function init() {
            // Wait until DOM is fully loaded
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', init);
                return;
            }

            // Show loading state
            document.getElementById('namespaceContainer').innerHTML = `
                <div style="text-align: center; padding: 50px; color: #718096;">
                    <h3>Loading Routes...</h3>
                    <p>Please wait while we load the configuration data.</p>
                </div>
            `;

            // Load routes data first
            const dataLoaded = await loadRoutesData();
            if (!dataLoaded) {
                return; // Error message already shown in loadRoutesData
            }

            setupSearch();
            setupStickyHeader();
            setupExportButtons();
            
            // Try to load state from URL
            const configLoaded = loadStateFromUrl();
            
            updateDisplay();
            updateStats();
            
            // If no config was loaded from URL, show initial empty configuration
            if (!configLoaded) {
                autoGenerateMcpConfig();
            }
        }

        // DOM-ready Check f√ºr alle Funktionen die DOM-Elemente brauchen
        function ensureDOMReady(callback) {
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', callback);
            } else {
                callback();
            }
        }

        // Beim Laden der Seite initialisieren - mit robustem DOM-Loading
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    </script>
</body>
</html>